# Auto-generated DAG for Workflow: ml_trainnig_pipeline
# Workflow ID: a4b69b3a-77c1-4faa-920e-5b86e5fffded
# Generated by MLOps Workflow System

from airflow import DAG
from airflow.operators.python import PythonOperator
from datetime import datetime, timedelta

# DAG default arguments
default_args = {
    'owner': 'mlops',
    'depends_on_past': False,
    'start_date': datetime(2024, 1, 1),
    'email_on_failure': False,
    'email_on_retry': False,
    'retries': 0,
}

# Create DAG
with DAG(
    dag_id='workflow_a4b69b3a-77c1-4faa-920e-5b86e5fffded',
    default_args=default_args,
    description='Updated description - Testing sync',
    schedule_interval='@daily',
    start_date=datetime(2024, 1, 1),
    catchup=False,
    tags=['mlops', 'auto-generated', 'ml_trainnig_pipeline']
) as dag:


    # Task: data_load
    def data_load_func(**context):
        """
        Auto-generated task function for: data_load
        """
        import json
        import numpy as np

        # Helper function to serialize data for XCom
        def serialize_for_xcom(obj):
            if isinstance(obj, np.ndarray):
                return obj.tolist()
            elif isinstance(obj, dict):
                return {k: serialize_for_xcom(v) for k, v in obj.items()}
            elif isinstance(obj, (list, tuple)):
                return [serialize_for_xcom(item) for item in obj]
            return obj

        # Execute user-defined code
        user_code = r'''# Write your Python code here
# You have access to the 'context' variable for XCom operations

print("Task started")
"""
Auto-generated task function for: load_data
"""
# User-defined Python code
import pandas as pd
import numpy as np
print("Loading data...")
data = {
    'feature1': np.random.rand(100),
    'feature2': np.random.rand(100),
    'target': np.random.randint(0, 2, 100)
}
df = pd.DataFrame(data)
print(f"Loaded {len(df)} samples")
context["ti"].xcom_push(key="dataset", value=data)


# Example: Push data to XCom
# context["ti"].xcom_push(key="result", value="some_value")

# Example: Pull data from XCom
# data = context["ti"].xcom_pull(task_ids="previous_task", key="result")

print("Task completed")
'''

        # Create a local namespace for execution
        local_vars = {'context': context, '__builtins__': __builtins__}

        # Execute the user code
        exec(user_code, local_vars)

        # If user defined a function with the same name as task_id, call it
        if 'data_load' in local_vars and callable(local_vars['data_load']):
            result = local_vars['data_load']()
            # Serialize result if it contains numpy arrays
            if result is not None:
                result = serialize_for_xcom(result)
            return result

    data_load = PythonOperator(
        task_id='data_load',
        python_callable=data_load_func,
        op_kwargs={},
        retries=2,
        retry_delay=timedelta(seconds=300),
        provide_context=True,
    )

    # Task: evaluate_model
    def evaluate_model_func(**context):
        """
        Auto-generated task function for: evaluate_model
        """
        import json
        import numpy as np

        # Helper function to serialize data for XCom
        def serialize_for_xcom(obj):
            if isinstance(obj, np.ndarray):
                return obj.tolist()
            elif isinstance(obj, dict):
                return {k: serialize_for_xcom(v) for k, v in obj.items()}
            elif isinstance(obj, (list, tuple)):
                return [serialize_for_xcom(item) for item in obj]
            return obj

        # Execute user-defined code
        user_code = r'''def evaluate_model():
    print('Evaluating model...')
    return {'status': 'success', 'metrics': {'precision': 0.94, 'recall': 0.96}}'''

        # Create a local namespace for execution
        local_vars = {'context': context, '__builtins__': __builtins__}

        # Execute the user code
        exec(user_code, local_vars)

        # If user defined a function with the same name as task_id, call it
        if 'evaluate_model' in local_vars and callable(local_vars['evaluate_model']):
            result = local_vars['evaluate_model']()
            # Serialize result if it contains numpy arrays
            if result is not None:
                result = serialize_for_xcom(result)
            return result

    evaluate_model = PythonOperator(
        task_id='evaluate_model',
        python_callable=evaluate_model_func,
        op_kwargs={},
        retries=1,
        retry_delay=timedelta(seconds=300),
        provide_context=True,
    )

    # Task: load_data
    def load_data_func(**context):
        """
        Auto-generated task function for: load_data
        """
        import json
        import numpy as np

        # Helper function to serialize data for XCom
        def serialize_for_xcom(obj):
            if isinstance(obj, np.ndarray):
                return obj.tolist()
            elif isinstance(obj, dict):
                return {k: serialize_for_xcom(v) for k, v in obj.items()}
            elif isinstance(obj, (list, tuple)):
                return [serialize_for_xcom(item) for item in obj]
            return obj

        # Execute user-defined code
        user_code = r'''def load_data():
    print('Loading training data...')
    return {'status': 'success', 'records': 1000}'''

        # Create a local namespace for execution
        local_vars = {'context': context, '__builtins__': __builtins__}

        # Execute the user code
        exec(user_code, local_vars)

        # If user defined a function with the same name as task_id, call it
        if 'load_data' in local_vars and callable(local_vars['load_data']):
            result = local_vars['load_data']()
            # Serialize result if it contains numpy arrays
            if result is not None:
                result = serialize_for_xcom(result)
            return result

    load_data = PythonOperator(
        task_id='load_data',
        python_callable=load_data_func,
        op_kwargs={},
        retries=3,
        retry_delay=timedelta(seconds=300),
        provide_context=True,
    )

    # Task: train_model
    def train_model_func(**context):
        """
        Auto-generated task function for: train_model
        """
        import json
        import numpy as np

        # Helper function to serialize data for XCom
        def serialize_for_xcom(obj):
            if isinstance(obj, np.ndarray):
                return obj.tolist()
            elif isinstance(obj, dict):
                return {k: serialize_for_xcom(v) for k, v in obj.items()}
            elif isinstance(obj, (list, tuple)):
                return [serialize_for_xcom(item) for item in obj]
            return obj

        # Execute user-defined code
        user_code = r'''def train_model():
    print('Training ML model...')
    return {'status': 'success', 'accuracy': 0.95}'''

        # Create a local namespace for execution
        local_vars = {'context': context, '__builtins__': __builtins__}

        # Execute the user code
        exec(user_code, local_vars)

        # If user defined a function with the same name as task_id, call it
        if 'train_model' in local_vars and callable(local_vars['train_model']):
            result = local_vars['train_model']()
            # Serialize result if it contains numpy arrays
            if result is not None:
                result = serialize_for_xcom(result)
            return result

    train_model = PythonOperator(
        task_id='train_model',
        python_callable=train_model_func,
        op_kwargs={'epochs': 100, 'batch_size': 32},
        retries=2,
        retry_delay=timedelta(seconds=600),
        provide_context=True,
    )


    # Task Dependencies





    train_model >> evaluate_model







    load_data >> train_model


